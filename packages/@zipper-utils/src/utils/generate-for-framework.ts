/**
 * ðŸ¦•
 * Please refrain from importing anything into this utility to keep it Deno-compatible
 */

const IMPORTS_REG_EXP = new RegExp(
  '/// <generated-imports[\\d\\D]*?/generated-imports>',
  'g',
);

const EXPORTS_REG_EXP = new RegExp(
  '/// <generated-exports[\\d\\D]*?/generated-exports>',
  'g',
);

const ZIPPER_CLIENT_JS_URL =
  'https://deno.land/x/zipper_client_js@v0.1.6/mod.ts';

const NEWLINE = '\n';

/**
 * camelCases filenames that use any seperator so that they work as module names
 *
 * @example
 * getExportNameFromFilename('do-something.ts')
 * // { function: 'doSomething', inputs: 'DoSomethingInputs', output: 'DoSomethingOutput' }
 * @example
 * getExportNameFromFilename('crypto.utils.ts')
 * // { function: 'cryptoUtils', inputs: 'CryptoUtilsInputs', output: 'CryptoUtilsOutput' }
 */
function getExportNamesFromFilename(filename: string) {
  const parts = filename.split('.');
  parts.pop();
  const camelCaseName = parts
    .join('.')
    .toLowerCase()
    .replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase());

  const UpperCaseName = `${camelCaseName
    .charAt(0)
    .toUpperCase()}${camelCaseName.slice(1)}`;

  return {
    function: camelCaseName,
    handlerType: `${UpperCaseName}Handler`,
    inputsType: `${UpperCaseName}Inputs`,
    outputType: `${UpperCaseName}Output`,
  };
}

export function generateModTs({
  subdomain,
  filenames,
}: {
  subdomain: string;
  filenames: string[];
}) {
  return [
    `import { initApplet } from '${ZIPPER_CLIENT_JS_URL}';`,

    // Actual import statements
    ...filenames.map((f, i) => `import * as module${i} from '/src/${f}';`),

    // Init applet by name
    `const applet = initApplet("${subdomain}");`,

    ...filenames.map((f, i) => {
      const names = getExportNamesFromFilename(f);
      const handlerType = `typeof module${i}.handler`;
      const paramsType = `Parameters<${handlerType}>`;
      const returnType = `ReturnType<${handlerType}>`;
      return [
        `export type ${names.outputType} = ${returnType} extends Promise<any> ? Awaited<${returnType}> : ${returnType};`,
        `export type ${names.inputsType} = ${paramsType} extends [] ? void : ${paramsType}[0];`,
        `export type ${names.handlerType} = ${paramsType} extends [] ? () => Promise<${names.outputType}> : (inputs: ${names.inputsType}) => Promise<${names.outputType}>;`,
        `export const ${names.function}: ${names.handlerType} = (...args: any) => applet.path("${f}").run<${names.inputsType}, ${names.outputType}>(...args) as any;`,
      ].join(NEWLINE);
    }),

    filenames.includes('main.ts') &&
      [
        'export default main;',
        'export type Inputs = MainInputs;',
        'export type Output = MainOutput;',
      ].join(NEWLINE),
  ]
    .filter((truthy) => !!truthy)
    .join(NEWLINE);
}

export function generateIndexForFramework({
  code,
  filenames: allFilenames,
}: {
  code: string;
  filenames: string[];
}) {
  // Filter out main since it's hardcoded
  const filenames = allFilenames.filter((f) => f !== 'main.ts');

  const generatedImports = [
    '/// <generated-imports>',
    '/// ðŸ›‘ DO NOT MODIFY THIS PART ///',
    '/// GENERATED BY packages/@zipper-utils/src/utils/generate-for-framework.ts',
    ...filenames.map((f, i) => `import * as module${i} from '../src/${f}';`),
    '/// </generated-imports>',
  ].join(NEWLINE);

  const generatedExports = [
    '/// <generated-exports>',
    '/// ðŸ›‘ DO NOT MODIFY THIS PART ///',
    '/// GENERATED BY packages/@zipper-utils/src/utils/generate-for-framework.ts',
    ...filenames.map((f, i) => `'${f}': module${i},`),
    '/// </generated-exports>',
  ].join(NEWLINE);

  return code
    .replace(IMPORTS_REG_EXP, generatedImports)
    .replace(EXPORTS_REG_EXP, generatedExports);
}
