/**
 * ðŸ¦•
 * Please refrain from importing anything into this utility to keep it Deno-compatible
 */

const IMPORTS_REG_EXP = new RegExp(
  '/// <generated-imports[\\d\\D]*?/generated-imports>',
  'g',
);

const EXPORTS_REG_EXP = new RegExp(
  '/// <generated-exports[\\d\\D]*?/generated-exports>',
  'g',
);

const ZIPPER_CLIENT_JS_URL =
  'https://deno.land/x/zipper_client_js@v0.1.6/mod.ts';

/**
 * camelCases filenames that use any seperator so that they work as module names
 *
 * @example
 * getExportNameFromFilename('do-something.ts')
 * // doSomething
 * @example
 * getExportNameFromFilename('crypto.utils.ts')
 * // cryptoUtils
 */
function getExportNameFromFilename(filename: string) {
  const parts = filename.split('.');
  parts.pop();
  return parts
    .join('.')
    .toLowerCase()
    .replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase());
}

export function generateModTs({
  subdomain: subdomain,
  filenames,
}: {
  subdomain: string;
  filenames: string[];
}) {
  return [
    `import { initApplet } from '${ZIPPER_CLIENT_JS_URL}';`,

    // Actual import statements
    ...filenames.map((f, i) => `import * as module${i} from '/src/${f}';`),

    // Init applet by name
    `const applet = initApplet("${subdomain}");`,

    // Type utilities
    `type Handler = (...args: any) => any;`,
    `type ExtractReturnType<H extends Handler> = ReturnType<H> extends Promise<any> ? ReturnType<H> : Promise<ReturnType<H>>;`,
    `type ExtractType<H extends Handler> = Parameters<H> extends [] ? () => ExtractReturnType<H> : (inputs: Parameters<H>[0]) => ExtractReturnType<H>;`,

    ...filenames.map(
      (f, i) =>
        `export const ${getExportNameFromFilename(
          f,
        )}: ExtractType<typeof module${i}.handler> = (...args) => applet.path("${f}").run(...args);`,
    ),

    filenames.includes('main.ts') && 'export default main;',
  ]
    .filter((truthy) => !!truthy)
    .join('\n');
}

export function generateIndexForFramework({
  code,
  filenames: allFilenames,
}: {
  code: string;
  filenames: string[];
}) {
  // Filter out main since it's hardcoded
  const filenames = allFilenames.filter((f) => f !== 'main.ts');

  const generatedImports = [
    '/// <generated-imports>',
    '/// ðŸ›‘ DO NOT MODIFY THIS PART ///',
    '/// GENERATED BY packages/@zipper-utils/src/utils/generate-for-framework.ts',
    ...filenames.map((f, i) => `import * as module${i} from '../src/${f}';`),
    '/// </generated-imports>',
  ].join(`\n`);

  const generatedExports = [
    '/// <generated-exports>',
    '/// ðŸ›‘ DO NOT MODIFY THIS PART ///',
    '/// GENERATED BY packages/@zipper-utils/src/utils/generate-for-framework.ts',
    ...filenames.map(
      (f, i) => `'${f.replace(/\.(ts|tsx)$|$/, '.ts')}': module${i},`,
    ),
    '/// </generated-exports>',
  ].join('\n');

  return code
    .replace(IMPORTS_REG_EXP, generatedImports)
    .replace(EXPORTS_REG_EXP, generatedExports);
}
