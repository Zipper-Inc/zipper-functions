// aifunctions route
import { NextResponse } from 'next/server';
import { Configuration, OpenAIApi } from 'openai';

export type ChatGPTAgent = 'user' | 'system' | 'assistant';
export interface ChatGPTMessage {
  role: ChatGPTAgent;
  content: string;
}

export interface ChatGPTFunction {
  name: string;
  description: string;
  parameters: {
    type: string;
    properties: {
      [key: string]: {
        type: string;
        description: string;
        enum?: string[];
      };
    };
    required: string[];
  };
}

const functions: ChatGPTFunction[] = [
  {
    name: 'generateAppletTypescriptCode',
    description:
      'Generates a basic typescript code that implements the user request using OpenAI',
    parameters: {
      type: 'object',
      properties: {
        userRequest: {
          type: 'string',
          description:
            "The user request. Example: I want a applet that can greet the user by it's name",
        },
      },
      required: ['userRequest'],
    },
  },
  {
    name: 'generateZipperAppletVersion',
    description:
      'Reimplementation of previous generated code but using Zipper functionalities',
    parameters: {
      type: 'object',
      properties: {
        userRequest: {
          type: 'string',
          description:
            "The user request. Example: I want a applet that can greet the user by it's name",
        },
        rawTypescriptCode: {
          type: 'string',
          description:
            'The raw typescript code generated by the previous function',
        },
      },
      required: ['userRequest', 'rawTypescriptCode'],
    },
  },
];

export const conf = new Configuration({
  apiKey: process.env.OPENAI,
});

export const systemPrompt = `
    You are a high skilled typescript developer, your task is to take the user request and generate typescript code. 
    Your code must export a handler function. You are not allowed to use classes. 
    Your final output should be a handler function that implements the user request.
    You should always only respond with the desired code, no additional text.
    Example: 
    User request: I want a applet that can greet the user by it's name
    Code: 
    export async function handler({name} : {name: string}){
      return \`Hello \${name}\`
    }

`;

export async function POST(req: Request) {
  const { userRequest, previousMessages } = await req.json();
  try {
    const newApplet = await chat({ previousMessages, userRequest });
    return NextResponse.json({ message: newApplet });
  } catch (error: any) {
    return NextResponse.json({ error: error.message });
  }
}

async function chat({
  previousMessages,
}: {
  previousMessages: ChatGPTMessage[];
  userRequest: string;
}) {
  const conf = new Configuration({
    apiKey: process.env.OPENAI,
  });

  if (conf.apiKey === undefined) {
    console.log('No API key provided.');
    return { error: 'No API key provided.' };
  }

  const openai = new OpenAIApi(conf);
  try {
    console.log('Creating chat completion...');
    const completion = await openai.createChatCompletion({
      model: 'gpt-3.5-turbo-16k-0613',
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        ...previousMessages,
      ],
      functions,
      temperature: 0.1,
      function_call: {
        name: 'generateAppletTypescriptCode',
      },
    });

    console.log(completion.data.choices[0]);

    return completion.data.choices[0]?.message;
  } catch (error: any) {
    console.log(error);
    if (error.response) {
      console.log(error.response.status);
      console.log(error.response.data);
      return {
        message: error.response.data?.error?.message ?? 'Unknown error',
      };
    } else {
      console.log(error);
      return {
        message: error.error?.message ?? 'Unknown error',
      };
    }
  }
}

async function generateZipperAppletVersion({
  userRequest,
  rawTypescriptCode,
}: {
  userRequest: string;
  rawTypescriptCode: string;
}) {
  const zipperSystemPrompt = `
  # Convert TypeScript to Zipper Applet

  Zipper allows creating serverless apps called applets. Applets contain handler functions that use types like Handler and Serializable.
  
  // zipper.d.ts contents 
  /**
 * ✨
 * The global namespace where Zipper-specific, non-standard APIs are located.
 * ✨
 */
declare namespace Zipper {
  /**
   * The most atomic unit of data in Zipper
   * @category Primitive
   */
  export type Primitive = string | Date | number | boolean | null | undefined;

  /**
   * Zipper objects can only be keyed by string or number
   * @category Primitive
   * @see Serializable
   */
  export type PrimitiveKey = string | number;

  /**
   * Any data structure that can me serialized into JSON
   * @category Primitive
   */
  export type Serializable =
    | Action
    | Component
    | Primitive
    | Serializable[]
    | { [key: PrimitiveKey]: Serializable };

  /**
   * A single value inside an Inputs object
   * @category Handler
   * @see Inputs
   * @see Handler
   */
  export type InputValue = undefined | Serializable;

  /**
   * The inputs for a Handler function
   * It's passed as a single object with named parameters
   * @category Handler
   * @see Handler
   */
  export type Inputs = { [key: string]: InputValue };

  /**
   * The output result of a Handler function
   * @category Handler
   * @see Handler
   */
  export type Output = void | Serializable;

  /**
   * Additional context that is passed to every handler
   * @category Handler
   * @see Handler
   */
  export type HandlerContext = {
    /**
     * The request object sent to this handler
     */
    request: Request;

    /**
     * An editable response object
     * Changes made to these properties will overwrite the default response
     */
    response: Partial<ResponseInit & { body: BodyInit }>;

    /**
     * Information about the user who called this app
     * (blank if public)
     */
    userInfo: undefined | UserInfo;

    /**
     * Meta info about the applet itself
     */
    appInfo: AppInfo;

    /**
     * The ID for this particular run
     */
    runId: string;
  };

  /**
   * A callable Handler function in Zipper's framework
   * Export a Handler function named 'handler' to turn your file into a path
   * You may pass in a input definition for autogenerated UI
   * @category Handler
   *
   * @example
   * // Define inputs without Zipper.Handler type
   * export function handler({ worldString } : { worldString: string }) {
   *   return Hello /$/{worldString}';
   * }
   *
   * // Define inputs with Zippler.Handler generic
   * export const handler: Zipper.Handler<{ worldString: string }> = ({
   *   worldString,
   * }) => 'Hello /$/{worldString}';
   */
  export type Handler<I = Inputs> = (
    inputs: I,
    context: HandlerContext,
  ) => Output | Promise<Output>;

  /**
   * The configuration for how each Handler is displayed or run
   * Can be exported at the page level
   */
  export type HandlerConfig<I = Inputs> = Partial<{
    run: boolean | I;
    auth: boolean;
    description: Partial<{
      title: string;
      subtitle: string;
    }>;
    inputs: {
      [Property in keyof I]: Partial<{
        label: string;
        description: string;
        defaultValue: I[Property];
        placeholder: string;
      }>;
    };
  }>;

  export type BootPayload = {
    ok: true;
    slug: string;
    version: string;
    appId: string;
    deploymentId: string;
    configs: { [path: string]: HandlerConfig };
  };

  /**
   * These are special objects we can return such as Actions
   * You must pass a string type to it, i.e. 'Zipper.Action'
   */
  interface SpecialOutput<zipperType extends 'Zipper./$/{string}'> {
    $zipperType: zipperType;
  }

  /**
   * Actions
   */
  interface ActionBase<I> {
    /**
     * Determines how we should show the input
     */
    showAs: 'modal' | 'expanded' | 'replace_all' | 'refresh';
    /**
     * The path to the handler for this action
     */
    path: string;
    /**
     * The visible text for the Action
     */
    text?: string;
    /**
     * Run the path with provided inputs and show the output
     * default = true
     */
    run?: boolean;
    /**
     * The inputs to run the function with
     */
    inputs?: I;
  }

  interface ButtonAction<I = Inputs> extends ActionBase<I> {
    /**
     * The type of action this is
     */
    actionType: 'button';
  }

  interface DropdownAction<I = Inputs> extends ActionBase<I> {
    /**
     * The type of action this is
     */
    actionType: 'dropdown';
    /**
     * Array of options in the dropdown.
     * Selected value is sent to the inputs function
     */
    options: Partial<{
      [Property in keyof I]: {
        label: string;
        value: I[Property];
      }[];
    }>;
  }

  export type Action<I = Inputs> = SpecialOutput<'Zipper.Action'> &
    (ButtonAction<I> | DropdownAction<I>);

  export type Component = SpecialOutput<'Zipper.Component'> &
    (StackComponent | LinkComponent | MarkdownComponent | HtmlElement);

  export interface ComponentBase {
    type: string;
    props?: JSX.Props;
    children?: Serializable;
  }

  type SelfPosition =
    | 'center'
    | 'end'
    | 'flex-end'
    | 'flex-start'
    | 'self-end'
    | 'self-start'
    | 'start';

  export interface StackComponent extends ComponentBase {
    type: 'stack';
    props?:
      | {
          direction: 'row' | 'column';
          divider?: boolean;
          align?: SelfPosition | 'baseline' | 'normal' | 'stretch';
        }
      | JSX.Props;
    children: Serializable;
  }

  export interface LinkComponent extends ComponentBase {
    type: 'link';
    props: {
      href: string;
      target?: '_blank' | '_self';
    };
    children: string;
    text?: string;
  }

  export interface MarkdownComponent extends ComponentBase {
    type: 'markdown';
    children: string;
  }

  export interface HtmlElement extends ComponentBase {
    type: 'html./$/{HtmlTag}';
  }

  export namespace Component {
    /**
     * Creates an action
     */
    export function create(
      component:
        | StackComponent
        | LinkComponent
        | MarkdownComponent
        | HtmlElement,
    ): Component;
  }

  export namespace Action {
    /**
     * Creates an action
     */
    export function create<I = Inputs>(
      action: ButtonAction<I> | DropdownAction<I>,
    ): Action<I>;
  }

  export namespace Log {
    type Method =
      | 'log'
      | 'debug'
      | 'info'
      | 'warn'
      | 'error'
      | 'table'
      | 'clear'
      | 'time'
      | 'timeEnd'
      | 'count'
      | 'assert';

    export interface Message {
      id: string;
      // The log method
      method: Method;
      // The arguments passed to console API
      data: Serializable[];
      // Time of log
      timestamp: number;
    }

    export type MessageorDisplay = Omit<Message, 'timestamp'> & {
      timestamp?: string;
    };
  }

  /**
   * Handle some special routing behavior
   * @category Runtime
   */
  export namespace Router {
    type Route = SpecialOutput<'Zipper.Router'>;

    export interface Redirect extends Route {
      redirect: string;
    }

    export interface NotFound extends Route {
      notFound: true;
    }

    export interface Error extends Route {
      error: string;
    }

    export function redirect(url: URL | string): Router.Redirect;
    export function notFound(): Router.NotFound;
    export function error(...data: unknown[]): Router.Error;
  }

  /**
   * Simple async key value store, one per app
   * @category Storage
   */
  export interface Storage<Value extends Serializable = Serializable> {
    appId: string;
    getAll<V extends Value = Value>(): Promise<{ [k: string]: V }>;
    get<V extends Value = Value>(key: string): Promise<V>;
    set<V extends Value = Value>(
      key: string,
      value: V,
    ): Promise<{ key: string; value: V }>;
    delete(key: string): Promise<true>;
  }

  /**
   * Information about the user who called this app
   * (blank if public)
   * @category Runtime
   */
  export type UserInfo = {
    email?: string;
  };

  /**
   * Meta info about the app itself
   * @category Runtime
   */
  export type AppInfo = {
    id: string;
    slug: string;
    version: string;
    url: string;
    connectorsWithUserAuth: string[];
  };

  /**
   * The namespace specific to the relay service
   * zipper.run <=> Deno deploy <=> @zipper/framework middleware
   * @category Runtime
   */
  export namespace Relay {
    /**
     * The Relay request body
     * POST by zipper.run to @zipper/framework
     */
    export type RequestBody = {
      error?: string;
      appInfo: AppInfo;
      runId: string;
      inputs: Inputs;
      userInfo?: UserInfo;
      originalRequest: { url: string; method: string };
      path?: string;
      userId: string;
    };
  }

  export namespace JSX {
    export type Props = Record<string, Serializable>;
    export type Children = Component['children'][];
    export function createElement(
      component: (props?: Props) => Component,
      props?: Props,
      ...children: Children
    ): Component;
    export function createElement(
      tag: Zipper.HtmlElement['type'],
      props?: Props,
      ...children: Children
    ): Component;
    export function Fragment({
      children,
    }: {
      children: Serializable;
    }): typeof children;
  }

  // *
  // * Zipper Global Properties
  // *

  /**
   * An object containing useful environment variables
   *
   * @example const myEnvVariable = Zipper.env.MY_ENV_VARIABLE;
   */
  export const env: Record<string, string>;

  /**
   * Simple async key value store, one per app
   *
   * @example
   * // get all values in storage
   * const allValues = await Zipper.storage.getAll();
   *
   * // get a single valueby key
   * const singleValue = await Zipper.storage.get('my-storage-key');
   *
   * // update a value by key
   * await Zipper.storage.set('another-storage-key', someStorageValue);
   *
   * // delete a value by key
   * await Zipper.storage.delete('another-store-key');
   */
  export const storage: Storage<Serializable>;
}

// Global components
type StackProps = Partial<Zipper.StackComponent['props']>;
declare function Stack(props: StackProps): Zipper.Component;
declare function Row(props?: StackProps): Zipper.Component;
declare function Column(props?: StackProps): Zipper.Component;

type LinkProps = Zipper.LinkComponent['props'];
declare function Link(props: LinkProps): Zipper.Component;

type ButtonProps<I> = Omit<Zipper.ButtonAction<I>, 'actionType' | 'text'>;
declare function Button<I = Zipper.Inputs>(
  props: ButtonProps<I>,
): Zipper.Action;

type MarkdownProps = { text?: string };
declare function Markdown(props: MarkdownProps): Zipper.Component;
declare function md(
  strings: TemplateStringsArray,
  ...expr: string[]
): Zipper.Component;

type DropdownProps<I> = Omit<Zipper.DropdownAction<I>, 'actionType'>;
declare function Dropdown<I = Zipper.Inputs>(
  props: DropdownProps<I>,
): Zipper.Action;
  
  Here is an example input TypeScript code:
  
  {rawTypescriptCode}
  
  Convert the above code into a properly formatted Zipper applet code. 
  
  The output should:
  
  - Use Zipper handler functions and types
  - You don't need to import anything from Zipper, everything is already available in the global namespace
  - Output should be only raw code, no additional text, no snippets, no \`\`\`typescript\`\`\` tags
  - Handler function should be always a declarative function, no arrow functions
  - Dont type the handler function because Zipper.Handler is already inferred
  - Zipper.Output type isnt necessary as well because it's inferred
  - You can use any code you want, but the output should be as simple as possible
  - Always try to create the config object for the handler function, even if it's empty
  - Config objects usually contains the inputs, description, auth and run properties, here is a example
  - It's always nice to have the description property so the user can understand what the applet does
  export const config: Zipper.HandlerConfig<Inputs> = {
    description: {
      title: "Greetings!",
      subtitle: 'A simple "Hello, world!" example on Zipper',
    },
    inputs: {
      name: {
        label: "Name",
        placeholder: "Enter a place to greet",
        description: "For example, entering 'world' would output 'Hello, world!",
      },
    },
  };
  
  
  {outputCode}
  `;
  const conf = new Configuration({
    apiKey: process.env.OPENAI,
  });

  if (conf.apiKey === undefined) {
    console.log('No API key provided.');
    return { error: 'No API key provided.' };
  }

  const openai = new OpenAIApi(conf);
  try {
    console.log('Creating chat completion...');
    const completion = await openai.createChatCompletion({
      model: 'gpt-3.5-turbo-16k-0613',
      messages: [
        {
          role: 'system',
          content: zipperSystemPrompt,
        },
        {
          role: 'user',
          content: userRequest,
        },
        {
          role: 'user',
          content: rawTypescriptCode,
        },
      ],
      temperature: 0.1,
    });

    console.log(completion.data.choices[0]);

    return completion.data.choices[0]?.message;
  } catch (error: any) {
    console.log(error);
    if (error.response) {
      console.log(error.response.status);
      console.log(error.response.data);
      return {
        message: error.response.data?.error?.message ?? 'Unknown error',
      };
    } else {
      console.log(error);
      return {
        message: error.error?.message ?? 'Unknown error',
      };
    }
  }
}
